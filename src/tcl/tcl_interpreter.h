#pragma once
/**
 * @file
 * @author  Alex Singer
 * @date    January 2026
 * @brief   A TCL-interpreter object used to parse SDC files.
 */

#include <cassert>
#include <tcl/tcl.h>
#include <string>

#include "sdc_wrapper.h"
#include "sdcparse.hpp"

extern "C" {
    /**
     * @brief Initialization command for the TCL interface generated by SWIG.
     *
     * NOTE: The naming convention of this function name is determined by SWIG.
     */
    extern int Sdc_commands_Init(Tcl_Interp* interp);
}

namespace sdcparse {

/**
 * @brief Global callback variable. This is used to interface the interpreter
 *        and the underlying callback which is handled by a downstream user.
 *
 * This variable is initialized by the TCL interpreter (only one interpreter
 * object can be alive at a time).
 *
 * This variable is then used by the interface functions to callback to the user.
 */
extern Callback* g_callback;

/**
 * @brief A TCL Interpreter object used to parse SDC files.
 *
 * Usage:
 *  // callback is an implementation of the callback object.
 *  TclInterpreter tcl_interpreter(callback);
 *
 *  tcl_interpreter.eval_file(sdc_file_path);
 *
 */
class TclInterpreter {
  private:
    /// @brief The TCL interpreter object.
    Tcl_Interp *interp;

    /// @brief Whether this class has been properly initialized or not.
    bool init_success_;

  public:
    /**
     * @brief Constructor for the TCL Interpreter object.
     *
     *  @param callback
     *      The callback which will be used when an SDC command is found.
     *  @param argv0
     *      (optional) The name of the calling program. This is used to initialize
     *      the TCL library.
     */
    TclInterpreter(Callback& callback, const char* argv0 = nullptr)
        : interp(nullptr), init_success_(false) {

        // Register the callback.
        if (g_callback != nullptr) {
            callback.parse_error(0, "", "Cannot register callback. A callback is already registered.");
            return;
        }
        g_callback = &callback;

        // Initialize the Tcl Library.
        static bool initLib = false;
        if (!initLib) {
            Tcl_FindExecutable(argv0);
            initLib = true;
        }

        // Create and initialize the Tcl Interpreter.
        interp = Tcl_CreateInterp();
        if (!interp) {
            callback.parse_error(0, "", "Failed to initialize Tcl library");
            return;
        }
        if (Tcl_Init(interp) != TCL_OK) {
            callback.parse_error(0, "", "Failed to init Tcl interpreter");
            return;
        }

        // Register the SWIG commands.
        if (Sdc_commands_Init(interp) != TCL_OK) {
            callback.parse_error(0, "", "SWIG module Sdc_commands_Init failed.");
            return;
        }

        // Add the sdc wrapper file.
        // This is used to make the C++ interfaces simpler.
        const char* sdc_wrapper = get_sdc_wrapper_script();
        if (Tcl_Eval(interp, sdc_wrapper) != TCL_OK) {
            print_error_log_();
            callback.parse_error(0, "", "Failed to evaluate SDC wrapper.");
            return;
        }

        // Mark this class as being fully initialized.
        init_success_ = true;
    }

    ~TclInterpreter() {
        // Delete the interpreter.
        if (interp)
            Tcl_DeleteInterp(interp);

        // Un-register the callback.
        // NOTE: This is not necessary, but it is just good to do.
        g_callback = nullptr;
    }

    /**
     * @brief Evaluate the given file using the TCL interpreter.
     *
     * Since SDC is a TCL file, this is used to parse SDC files; but it can
     * also be used for any TCL-compliant file.
     */
    void eval_file(const std::string& filename) {
        // Ensure that the class was initialized correctly.
        assert(g_callback != nullptr && "Callback must be registered");
        if (!init_success_) {
            g_callback->parse_error(0, "", "Failed to parse due to interpreter initialization error.");
            return;
        }

        // Signal the start of the parse.
        g_callback->start_parse();

        // Set the filename.
        g_callback->filename(filename);

        // Use the interpreter to evaluate the file.
        int code = Tcl_EvalFile(interp, filename.c_str());

        // Check for any errors.
        if (code == TCL_ERROR) {
            // NOTE: The stack trace here is very detailed, and may be too
            //       detailed for a user.
            // TODO: Make this optionally activated.
            print_error_log_();

            // Get the error line number.
            // Get the return options dictionary
            Tcl_Obj *options = Tcl_GetReturnOptions(interp, code);
            Tcl_Obj *lineKey = Tcl_NewStringObj("-errorline", -1);
            Tcl_Obj *lineVal;
            // Extract the line number from the dictionary
            Tcl_DictObjGet(NULL, options, lineKey, &lineVal);

            int line_number;
            if (lineVal != nullptr) {
                Tcl_GetIntFromObj(interp, lineVal, &line_number);
            } else {
                line_number = 0;
            }
            // Clean up
            Tcl_DecrRefCount(lineKey);
            Tcl_DecrRefCount(options);

            // Signal that an error has occurred.
            g_callback->parse_error(line_number, "", Tcl_GetStringResult(interp));
        }

        // Signal the end of parsing.
        g_callback->finish_parse();
    }

  private:
    /**
     * @brief Print the error log from the TCL interpreter.
     *
     * When the interpreter reaches an error, it provides error information
     * within its datastructures.
     *
     * This method prints the error message as well as a stack-trace of where
     * the error came from.
     */
    void print_error_log_() {
        g_callback->log_error_msg("--- SDC TCL Parse Error ---\n");
        g_callback->log_error_msg("Message: ");
        const char* msg = Tcl_GetStringResult(interp);
        g_callback->log_error_msg(msg);
        g_callback->log_error_msg("\n");

        const char* stack_trace = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
        if (stack_trace) {
            g_callback->log_error_msg("Stack Trace:\n");
            g_callback->log_error_msg(stack_trace);
            g_callback->log_error_msg("\n");
        }
        g_callback->log_error_msg("---------------------------\n");
    }
};

} // namespace sdcparse
