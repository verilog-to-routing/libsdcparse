#ifndef SDC_H
#define SDC_H
/*
 * libsdcparse - Kevin E. Murray 2014
 *
 * Released under MIT License see LICENSE.txt for details.
 *
 * OVERVIEW
 * --------------------------
 * This library provides basic parsing capabilities for a subset of commands in
 * Synopsys Design Constraint (SDC) files.  SDC files are typically used to 
 * set timing constraints on digital circuits.
 *
 * USING THIS LIBRARY
 * --------------------------
 * Since this is NOT a full TCL interpreter, 'function calls' to get_ports or
 * get_clocks, are converted to string_group, with the group_type field set
 * to either StringType::CLOCK or StringType::SDC_PORT respectively. That is, 
 * they are represented as the sets of the strings passed to those functions.  
 * It is left up to the application to interpret them.
 *
 * After parsing, each SDC command is represented as a C struct.  Typically each
 * command is parsed into a unique type of struct, however some closely related commands
 * (such as set_input_delay and set_output_delay) may share a struct and be identified
 * by a 'type' field in the struct.
 *
 * All supported SDC commands are collected into a commands struct which
 * represents the entire SDC file.
 *
 * See the associated main.c for example usage.
 *
 * EXTENDING THE LIBRARY
 * --------------------------
 * The parser uses a lexer generated by 'flex' (see sdc_parse.l), and a parser
 * generated by 'bison' (see sdc_parse.y).
 *
 * While the parser currently supports only a subset of the full SDC specification,
 * it should be relatively straightforward to extend it as follows:
 *
 *      1) To add a new option to an existing command
 *          a) Add the new token definition to sdc_parse.y (e.g. ARG_HOLD)
 *          b) Add a pattern to sdc_parse.l which returns the token (e.g. '-hold')
 *          c) Add a new (optional) rule to the appropriate command in sdc_parse.y
 *          d) Add an action for the added rule which makes the appropriate
 *             modifications to the command's struct.  It likely that you will
 *             want to do this as a function call and put the function definition
 *             in sdc_common.c. If the option may conflict with others it is
 *             typically checked at this point, with errors reported using sdc_error().
 *          e) Command is automatically added using the appropriate add_sdc*()
 *             function, which also verifies the options.  Command level consistency
 *             checks (e.g. option required) typically go here.
 *
 *      2) To add a new command
 *          a) Add the new token definition to sdc_parse.y (e.g. CMD_SET_TIME_FORMAT)
 *          b) Add a pattern to sdc_parse.l which returns the token (e.g. 'set_time_format')
 *          c) Add a new rule for the command to sdc_parse.y e.g.:
 *                cmd_set_time_format: CMD_SET_TIME_FORMAT
 *          d) Create a new C struct to represent the command, and write an alloc function
 *             (in sdc_common.c) that is called by the first rule e.g.:
 *                cmd_set_time_format: CMD_SET_TIME_FORMAT {$$ = alloc_sdc_set_time_units();}
 *          c) Add options to the command as outlined in (1)
 *          d) Create an add_sdc*() command and extend the s_sdc_commands struct to include 
 *             the new command.  Call it in the top level sdc_commands rule e.g.:
 *
 *                sdc_commands: ...
 *                   | ... //Other commands
 *                   | sdc_commands cmd_set_time_format EOL {$$ = add_sdc_set_time_format($1, $2); }
 *
 */
#include <cassert>
#include <functional>
#include <unordered_map>
#include <vector>
#include <string>
#include <limits>

namespace sdcparse {
struct ObjectId {
    explicit ObjectId(const std::string& v) noexcept
        : value(v) {}

    bool operator==(const ObjectId& rhs) const {
        return rhs.value == value;
    }

    std::string to_string() const {
        return value;
    }

    friend std::hash<ObjectId>;
  private:
    // TODO: Consider changing this to be an integer and a type.
    std::string value;
};
struct ClockObjectId : ObjectId {
    using ObjectId::ObjectId;
};
struct CellObjectId : ObjectId {
    using ObjectId::ObjectId;
};
struct PortObjectId : ObjectId {
    using ObjectId::ObjectId;
};
struct PinObjectId : ObjectId {
    using ObjectId::ObjectId;
};
}

namespace std {
    template<>
    struct hash<sdcparse::ObjectId> {
        std::size_t operator()(const sdcparse::ObjectId& obj) const noexcept {
            return std::hash<std::string>{}(obj.to_string());
        }
    };
    template<>
    struct hash<sdcparse::PortObjectId> {
        std::size_t operator()(const sdcparse::PortObjectId& obj) const noexcept {
            return std::hash<std::string>{}(obj.to_string());
        }
    };
}

namespace sdcparse {
/*
 * Forward declarations
 */
enum class IoDelayType;
enum class ClockGroupsType;
enum class FromToType;
enum class McpType;
enum class StringGroupType;

struct CreateClock;
struct SetIoDelay;
struct SetClockGroups;
struct SetFalsePath;
struct SetMinMaxDelay;
struct SetMulticyclePath;
struct SetClockUncertainty;
struct SetClockLatency;
struct SetDisableTiming;
struct SetTimingDerate;

struct StringGroup;

enum class PortDirection {
    INPUT,
    OUTPUT,
    INOUT,
    UNKNOWN
};

static inline PortDirection get_port_direction(std::string port_type) {
    if (port_type == "INPUT")
        return PortDirection::INPUT;
    if (port_type == "OUTPUT")
        return PortDirection::OUTPUT;
    if (port_type == "INOUT")
        return PortDirection::INOUT;
    return PortDirection::UNKNOWN;
}

// TODO: The TimingObjectDatabase should be moved to its own isolated file, maybe even dir.
class TimingObjectDatabase {
  private:
    std::unordered_map<ObjectId, std::string> object_name;
    std::unordered_map<PortObjectId, PortDirection> port_direction_;
    std::vector<PortObjectId> port_objects;
    std::vector<ClockObjectId> clock_objects;
    std::vector<PinObjectId> pin_objects;
    std::vector<CellObjectId> cell_objects;
  public:
    PortObjectId create_port_object(std::string port_name, PortDirection port_direction) {
        PortObjectId port_object_id = PortObjectId("__vtr_obj_port_" + std::to_string(port_objects.size()));
        assert(object_name.count(port_object_id) == 0);
        object_name[port_object_id] = port_name;
        port_direction_[port_object_id] = port_direction;
        port_objects.push_back(port_object_id);
        return port_object_id;
    }

    ClockObjectId create_clock_object(std::string clock_name) {
        ClockObjectId clock_object_id = ClockObjectId("__vtr_obj_clock_" + std::to_string(clock_objects.size()));
        assert(object_name.count(clock_object_id) == 0);
        object_name[clock_object_id] = clock_name;
        clock_objects.push_back(clock_object_id);
        return clock_object_id;
    }

    PinObjectId create_pin_object(std::string pin_name) {
        PinObjectId pin_object_id = PinObjectId("__vtr_obj_pin_" + std::to_string(pin_objects.size()));
        assert(object_name.count(pin_object_id) == 0);
        object_name[pin_object_id] = pin_name;
        pin_objects.push_back(pin_object_id);
        return pin_object_id;
    }

    CellObjectId create_cell_object(std::string cell_name) {
        CellObjectId cell_object_id = CellObjectId("__vtr_obj_cell_" + std::to_string(cell_objects.size()));
        assert(object_name.count(cell_object_id) == 0);
        object_name[cell_object_id] = cell_name;
        cell_objects.push_back(cell_object_id);
        return cell_object_id;
    }

    inline bool is_object_id(std::string object_id) const {
        if (object_id.rfind("__vtr_obj_", 0) == 0) {
            return true;
        }

        return false;
    }

    inline std::string get_object_name(ObjectId object_id) const {
        auto it = object_name.find(object_id);
        assert(it != object_name.end());
        return it->second;
    }

    const std::vector<std::string> get_port_objects() const {
        std::vector<std::string> all_ports;
        all_ports.reserve(port_objects.size());
        for (const PortObjectId& port_id: port_objects) {
            all_ports.push_back(port_id.to_string());
        }
        return all_ports;
    }

    const std::vector<std::string> get_input_port_objects() const {
        std::vector<std::string> all_inputs;
        all_inputs.reserve(port_objects.size());
        for (const PortObjectId& input: port_objects) {
            auto it = port_direction_.find(input);
            assert(it != port_direction_.end());
            if (it->second == PortDirection::INPUT || it->second == PortDirection::INOUT) {
                all_inputs.push_back(input.to_string());
            }
        }

        return all_inputs;
    }

    const std::vector<std::string> get_output_port_objects() const {
        std::vector<std::string> all_outputs;
        all_outputs.reserve(port_objects.size());
        for (const PortObjectId& output: port_objects) {
            auto it = port_direction_.find(output);
            assert(it != port_direction_.end());
            if (it->second == PortDirection::OUTPUT || it->second == PortDirection::INOUT) {
                all_outputs.push_back(output.to_string());
            }
        }

        return all_outputs;
    }

    const std::vector<std::string> get_clock_objects() const {
        std::vector<std::string> all_clocks;
        all_clocks.reserve(clock_objects.size());
        for (const ClockObjectId& clock_id : clock_objects) {
            all_clocks.push_back(clock_id.to_string());
        }
        return all_clocks;
    }

    const std::vector<std::string> get_pin_objects() const {
        std::vector<std::string> all_pins;
        all_pins.reserve(pin_objects.size());
        for (const PinObjectId& pin_id : pin_objects) {
            all_pins.push_back(pin_id.to_string());
        }
        return all_pins;
    }

    const std::vector<std::string> get_cell_objects() const {
        std::vector<std::string> all_cells;
        all_cells.reserve(cell_objects.size());
        for (const CellObjectId& cell_id : cell_objects) {
            all_cells.push_back(cell_id.to_string());
        }
        return all_cells;
    }
};

class Callback {

    public:
        virtual ~Callback() {}

        //Start of parsing
        virtual void start_parse() = 0;

        //Sets current filename
        virtual void filename(std::string fname) = 0;

        //Sets current line number
        virtual void lineno(int line_num) = 0;

        virtual void create_clock(const CreateClock& cmd) = 0;
        virtual void set_io_delay(const SetIoDelay& cmd) = 0;
        virtual void set_clock_groups(const SetClockGroups& cmd) = 0;
        virtual void set_false_path(const SetFalsePath& cmd) = 0;
        virtual void set_min_max_delay(const SetMinMaxDelay& cmd) = 0;
        virtual void set_multicycle_path(const SetMulticyclePath& cmd) = 0;
        virtual void set_clock_uncertainty(const SetClockUncertainty& cmd) = 0;
        virtual void set_clock_latency(const SetClockLatency& cmd) = 0;
        virtual void set_disable_timing(const SetDisableTiming& cmd) = 0;
        virtual void set_timing_derate(const SetTimingDerate& cmd) = 0;

        //End of parsing
        virtual void finish_parse() = 0;

        //Error during parsing
        virtual void parse_error(const int curr_lineno, const std::string& near_text, const std::string& msg) = 0;

        virtual void parse_warning(const std::string& msg) = 0;

    public:
        TimingObjectDatabase obj_database;
};

/*
 * External functions for loading an SDC file
 */
void sdc_parse_filename(std::string filename, Callback& callback, bool use_tcl_interp = true);
void sdc_parse_filename(const char* filename, Callback& callback, bool use_tcl_interp = true);

//Loads from 'sdc'. 'filename' only used to pass a filename to callback and can be left unspecified
void sdc_parse_file(FILE* sdc, Callback& callback, const char* filename=""); 

/*
 * Sentinal values
 */
constexpr double UNINITIALIZED_FLOAT = std::numeric_limits<double>::quiet_NaN();
constexpr int UNINITIALIZED_INT = -1;

/*
 * Enumerations to describe specific SDC command types and attributes
 */
enum class IoDelayType {
    INPUT, 
    OUTPUT
};

enum class MinMaxType {
    MIN,
    MAX,
    NONE
};

enum class ClockGroupsType {
    NONE,
    EXCLUSIVE
};

enum class FromToType {
    FROM,
    TO
};

enum class ClockLatencyType {
    SOURCE,
    NONE
};

enum class StringGroupType {
    STRING, 
    PORT, 
    CLOCK,
    CELL,
    PIN,
    OBJECT
};

/*
 * Common SDC data structures
 */

struct StringGroup {
    StringGroup() = default;
    StringGroup(StringGroupType group_type)
        : type(group_type) {}

    StringGroupType type = StringGroupType::STRING;   //The type of the string group, default is STRING. 
                                                            // Groups derived from 'calls' to [get_clocks {...}] 
                                                            // and [get_ports {...}] will have types SDC_CLOCK 
                                                            // and SDC_PORT respectively.
    std::vector<std::string> strings;                       //The strings in the group
};

/*
 * Structures defining different SDC commands
 */
struct CreateClock {
    std::string name = "";                      //Name of the clock
    double period = UNINITIALIZED_FLOAT;        //Clock period
    double rise_edge = UNINITIALIZED_FLOAT;     //Rise time from waveform definition
    double fall_edge = UNINITIALIZED_FLOAT;     //Fall time from waveform definition
    StringGroup targets;                        //The set of strings indicating clock sources.
                                                // May be explicit strings or regexs.
    bool is_virtual = false;                    //Identifies this as a virtual (non-netlist) clock
    bool add = false;
};

struct SetIoDelay {
    SetIoDelay() = default;
    SetIoDelay(IoDelayType io_type)
        : type(io_type) {}

    IoDelayType type = IoDelayType::INPUT;          //Identifies whether this represents a
                                                    // set_input_delay or set_output delay
                                                    // command.
    bool is_min = false;                            //Does delay apply for maximum delays?
    bool is_max = false;                            //Does delay apply for minimum delays?
                                                    // Note: is_min/is_max correspond to whether the option was 
                                                    // provided, it is up to the application to handle the case 
                                                    // where both are left unspecified (which SDC treats as 
                                                    // implicitly specifying both)
    std::string clock_name = "";                    //Name of the clock this constraint is associated with
    double delay = UNINITIALIZED_FLOAT;             //The maximum input delay allowed on the target ports
    StringGroup target_ports;                       //The target ports
};

struct SetClockGroups {
    ClockGroupsType type = ClockGroupsType::NONE;   //The type of clock group relation being specified
    std::vector<StringGroup> clock_groups;          //The groups of clocks
};

struct SetFalsePath {
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks
};

struct SetMinMaxDelay {
    SetMinMaxDelay() = default;
    SetMinMaxDelay(MinMaxType delay_type)
        : type(delay_type) {}
    MinMaxType type = MinMaxType::NONE;         //Whether this is a min or max delay
    double value = UNINITIALIZED_FLOAT;         //The maximum/minimum allowed delay between the from
                                                // and to clocks
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks
};

struct SetMulticyclePath {
    bool is_setup = false;                      //Does mcp_value apply for setup?
    bool is_hold = false;                       //Does mcp_value apply for hold?
                                                // Note: is_setup/is_hold correspond to whether the option was 
                                                // provided, it is up to the application to handle the case 
                                                // where both are left unspecified (which SDC treats as
                                                // applying mcp_value for the setup mcp, and 0 for the hold 
                                                // mcp)
    int mcp_value = UNINITIALIZED_INT;          //The number of cycles specifed
    StringGroup from;                           //The source list of startpoints or clocks
    StringGroup to;                             //The target list of endpoints or clocks
};

struct SetClockUncertainty {
    bool is_setup = false;                      //Does value apply for setup?
    bool is_hold = false;                       //Does value apply for hold?
                                                // Note: is_setup/is_hold correspond to whether the option was 
                                                // provided, it is up to the application to handle the case 
                                                // where both are left unspecified (which SDC treats as 
                                                // implicitly specifying both)
    float value = UNINITIALIZED_FLOAT;          //The uncertainty value

    StringGroup from;                           //Launch clock domain(s)
    StringGroup to;                             //Capture clock domain(s)
};

struct SetClockLatency {
    ClockLatencyType type = ClockLatencyType::NONE;//Latency type
    bool is_early = false;                         //Does value apply for early transitions?
    bool is_late = false;                          //Does value apply for late transitions?
                                                   // Note: is_early/is_late correspond to whether the option was 
                                                   // provided, it is up to the application to handle the case 
                                                   // where both are left unspecified (which SDC treats as 
                                                   // implicitly specifying both)
    float value = UNINITIALIZED_FLOAT;             //The latency value

    StringGroup target_clocks;                     //The target clocks
};

struct SetDisableTiming {
    StringGroup from;                           //The source pins
    StringGroup to;                             //The sink pins
};

struct SetTimingDerate {
    bool is_early = false;                      //Does value apply for early transitions?
    bool is_late = false;                       //Does value apply for late transitions?
                                                // Note: is_early/is_late correspond to whether the option was 
                                                // provided, it is up to the application to handle the case 
                                                // where both are left unspecified (which SDC treats as 
                                                // implicitly specifying both)
    bool derate_nets = false;                   //Should nets be derated?
    bool derate_cells = false;                  //Should cells be derated?

    float value = UNINITIALIZED_FLOAT;          //The derate value

    StringGroup cell_targets;                   //The (possibly empty) set of target cells
};

} //namespace

#endif
